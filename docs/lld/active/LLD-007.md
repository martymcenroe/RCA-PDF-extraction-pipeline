# 10007 - Feature: Refactor core_analysis_minimal.py for Modularity

## 1. Context & Goal
* **Issue:** #7
* **Objective:** Extract the monolithic `main()` function into 7-8 focused functions for testability and maintainability
* **Status:** Approved
* **Related Issues:** #10 (Pylint score improvement)
* **Effort Estimate:** S (Small)

### Open Questions
*Questions that need clarification before or during implementation. Remove when resolved.*

- [x] Should type hints use `typing` module or Python 3.10+ native syntax? **Decision: Python 3.9+ native (list, dict)**
- [ ] Target line count per function? (Proposed: max 50 lines)
- [ ] Is Pylint 8.0/10 sufficient or should we target 9.0+?

## 2. Proposed Changes

*This section is the **source of truth** for implementation. Describe exactly what will be built.*

### 2.1 Files Changed

| File | Change Type | Description |
|------|-------------|-------------|
| `src/core_analysis_minimal.py` | Modify | Refactor into 7-8 discrete functions |
| `tests/test_core_analysis_minimal.py` | Add | Unit tests for extracted functions |
| `tests/fixtures/mock_pages.py` | Add | Dictionary-based mock page data |
| `tests/fixtures/known_bad.pdf` | Add | Intentionally corrupted PDF for error handling tests |

### 2.2 Offline Development Strategy

**Mock Mode:** Since `fitz` (PyMuPDF) is a C-based dependency that's difficult to mock, define dictionary-based mock data that functions can accept for unit testing without a live `fitz` environment.

```python
# tests/fixtures/mock_pages.py - Dictionary-based mock for fitz.Page

MOCK_TABLE_PAGE = {
    "page_number": 39,
    "text": "Sample No.\tDepth (ft)\tPermeability Air\n6-1\t9580.5\t0.042\n...",
    "text_blocks": [...],
    "image_count": 0,
    "line_count": 15,
}

MOCK_PLOT_PAGE = {
    "page_number": 45,
    "text": "Figure 3.1: Porosity vs Depth",
    "text_blocks": [...],
    "image_count": 1,
    "line_count": 2,
}

# Functions accept either fitz.Page or mock dict via duck typing
def classify_page(page) -> str:
    if isinstance(page, dict):
        text = page["text"]
        line_count = page["line_count"]
    else:
        text = page.get_text()
        line_count = len(page.get_drawings())
    ...
```

**Development Workflow:**
1. Create mock page dicts with representative patterns
2. Develop classify_page() using mocks - no PDF needed
3. Develop extract_samples_from_page() using mock text
4. Integration test with real PDF as final step

### 2.3 Dependencies

*New packages, APIs, or services required.*

```toml
# No new dependencies - maintain "minimal" philosophy
# Uses only: argparse, csv, json, pathlib (standard library)
```

### 2.4 Data Structures

```python
# Resource safety limits
MAX_PAGES = 500  # Prevent runaway processing on unexpectedly large PDFs

# No other new data structures - behavior-preserving refactor
```

### 2.5 Function Signatures

```python
# src/core_analysis_minimal.py - Target function inventory

def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    ...

def validate_output_path(output_path: Path, project_root: Path) -> bool:
    """Validate output path is within project worktree."""
    ...

def classify_page(page) -> str:
    """Classify a single page as 'table', 'plot', 'cover', 'text', or 'other'.

    Accepts fitz.Page or mock dict for testing.
    """
    ...

def classify_document(doc, max_pages: int = MAX_PAGES) -> dict[int, str]:
    """Iterate pages and build classification dictionary.

    Args:
        doc: fitz.Document or mock
        max_pages: Safety limit to prevent runaway processing

    Raises:
        ValueError: If document exceeds MAX_PAGES
    """
    ...

def extract_samples_from_page(page) -> list[dict]:
    """Parse table page text and extract sample records.

    Accepts fitz.Page or mock dict for testing.
    """
    ...

def extract_all_samples(doc, classifications: dict[int, str]) -> list[dict]:
    """Iterate table pages and collect all samples."""
    ...

def write_csv(samples: list[dict], output_path: Path, project_root: Path) -> None:
    """Write samples to CSV file.

    Validates output_path is within project_root before writing.
    """
    ...

def write_json(samples: list[dict], output_path: Path, project_root: Path) -> None:
    """Write samples to JSON file.

    Validates output_path is within project_root before writing.
    """
    ...

def main() -> int:
    """Orchestrate the extraction pipeline.

    Returns:
        Exit code: 0 for success, 1 for failure
    """
    ...
```

### 2.6 Logic Flow (Pseudocode)

```
main():
1. args = parse_args()
2. Validate output path is within project worktree
   - IF invalid: print error, return exit code 1
3. Open PDF document
4. IF doc.page_count > MAX_PAGES:
   - Log error, return exit code 1 (FAIL CLOSED)
5. TRY:
   - classifications = classify_document(doc)
   EXCEPT ClassificationError:
   - Log error, return exit code 1 (FAIL CLOSED - do not proceed to extraction)
6. TRY:
   - samples = extract_all_samples(doc, classifications)
   EXCEPT ExtractionError:
   - Log error, return exit code 1 (FAIL CLOSED)
7. write_csv(samples, args.output / "core_analysis.csv")
8. write_json(samples, args.output / "core_analysis.json")
9. Log INFO: "Extracted {n} samples from {p} pages"
10. Return exit code 0

# Each function is independently testable
```

### 2.7 Technical Approach

* **Module:** `src/core_analysis_minimal.py`
* **Pattern:** Functional decomposition with single responsibility per function
* **Key Decisions:**
  - Functions return data rather than mutating shared state
  - Type hints on all signatures for clarity
  - Google-style docstrings for documentation
  - Maintain single-file structure (no module splitting)

## 3. Requirements

*What must be true when this is done. These become acceptance criteria.*

1. File contains 7-8 distinct functions (up from 1)
2. `grep -c "^def " src/core_analysis_minimal.py` returns >= 7
3. Running script produces identical output to before refactor
4. Each function has type hints and docstring
5. Pylint score >= 8.0/10
6. No new dependencies added
7. File remains under 250 lines

## 4. Alternatives Considered

| Option | Pros | Cons | Decision |
|--------|------|------|----------|
| Split into modules | Better organization | Violates "minimal" philosophy | **Rejected** |
| Class-based refactor | Encapsulation | Overkill for this size | **Rejected** |
| Functional decomposition | Simple, testable, single file | None significant | **Selected** |

**Rationale:** Functional decomposition maintains the "minimal" single-file philosophy while enabling unit testing.

## 5. Data & Fixtures

### 5.1 Data Sources

| Attribute | Value |
|-----------|-------|
| Source | W20552.pdf (for regression testing) |
| Format | PDF |
| Size | ~50 pages |
| Refresh | Static |
| Copyright/License | Assignment material |

### 5.2 Data Pipeline

```
No change to data pipeline - behavior-preserving refactor
```

### 5.3 Test Fixtures

| Fixture | Source | Notes |
|---------|--------|-------|
| Mock fitz.Page | Generated | For unit testing classify_page |
| Sample page text | Extracted | For testing extract_samples_from_page |
| Before/after CSV | Generated | For regression comparison |

### 5.4 Deployment Pipeline

N/A - No deployment changes.

## 6. Diagram

N/A - Simple function extraction, no architectural changes.

## 7. Security Considerations

| Concern | Mitigation | Status |
|---------|------------|--------|
| Worktree scope | Validate output path within project directory | TODO |
| Runaway processing | MAX_PAGES = 500 limit | Addressed |
| Partial pipeline failures | Fail Closed - abort on critical errors | Addressed |

**Fail Mode:** Fail Closed - If classification or extraction fails, abort with exit code 1. Do not produce partial/incomplete output.

### 7.1 Logging Strategy

| Event | Level | Message Format |
|-------|-------|----------------|
| Pipeline start | INFO | `Processing {pdf_path}` |
| Classification complete | INFO | `Classified {n} pages: {summary}` |
| Page classified | DEBUG | `Page {n}: {classification}` |
| Extraction complete | INFO | `Extracted {n} samples from {p} table pages` |
| Sample extracted | DEBUG | `Sample {sample_number} from page {page}` |
| Pipeline success | INFO | `Output written to {output_path}` |
| Pipeline failure | ERROR | `Pipeline failed: {error}` |

## 8. Performance Considerations

| Metric | Budget | Approach |
|--------|--------|----------|
| No change | Same as before | Behavior-preserving refactor |

**Bottlenecks:** None introduced - same code, different organization.

## 9. Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Regression in output | High | Low | Before/after diff comparison |
| Function boundary wrong | Med | Med | Code review, test coverage |

## 10. Verification & Testing

### 10.1 Test Scenarios

| ID | Scenario | Type | Input | Expected Output | Pass Criteria |
|----|----------|------|-------|-----------------|---------------|
| 010 | Regression test | Auto | W20552.pdf | Same CSV as before | `diff` returns empty |
| 020 | classify_page table | Auto | Mock table page | "table" | Correct classification |
| 030 | classify_page plot | Auto | Mock plot page | "plot" | Correct classification |
| 040 | extract_samples | Auto | Known page text | Expected samples | Correct extraction |
| 050 | Pylint score | Auto | Refactored file | >= 8.0 | Score threshold |
| 060 | Function count | Auto | Refactored file | >= 7 | grep count |
| 070 | Known bad PDF | Auto | known_bad.pdf | Exit code 1 | Error handling triggers |
| 080 | Path validation | Auto | "../../../etc/output" | Exit code 1 | Invalid path rejected |

### 10.2 Test Commands

```bash
# Regression test
python src/core_analysis_minimal.py docs/context/init/W20552.pdf --output ./before/
# ... refactor ...
python src/core_analysis_minimal.py docs/context/init/W20552.pdf --output ./after/
diff before/core_analysis.csv after/core_analysis.csv

# Unit tests
pytest tests/test_core_analysis_minimal.py -v

# Pylint check
python -m pylint src/core_analysis_minimal.py --score=y

# Function count
grep -c "^def " src/core_analysis_minimal.py
```

### 10.3 Manual Tests (Only If Unavoidable)

N/A - All scenarios automated.

## 11. Definition of Done

### Code
- [ ] Implementation complete and linted
- [ ] All 7-8 functions extracted and working
- [ ] Type hints on all function signatures
- [ ] Docstrings on all functions

### Tests
- [ ] All test scenarios pass
- [ ] Test coverage >= 70%
- [ ] Regression test passes (identical output)

### Documentation
- [ ] LLD updated with any deviations
- [ ] Implementation Report completed

### Review
- [ ] Code review completed
- [ ] Pylint score >= 8.0/10

---

## Appendix: Review Log

*Track all review feedback with timestamps and implementation status.*

### Gemini 3 Pro Review #1 (REVISE)

**Timestamp:** 2026-01-29
**Reviewer:** Gemini 3 Pro (Senior Software Architect & AI Governance Lead)
**Verdict:** REVISE

#### Comments

| ID | Comment | Implemented? |
|----|---------|--------------|
| G1.1 | "Unbounded Loop Execution (BLOCKING): Add MAX_PAGES safety check" | YES - Added MAX_PAGES = 500 in Section 2.4 |
| G1.2 | "Worktree Scope (BLOCKING): Validate output path in write_csv/write_json" | YES - Added validate_output_path() in Section 2.5 |
| G1.3 | "Fail-Safe Strategy (BLOCKING): Define Fail Closed for pipeline failures" | YES - Added to Section 2.6 and 7 |
| G1.4 | "Offline Development (CRITICAL): Define dictionary-based mock format for fitz.Page" | YES - Added Section 2.2 with mock_pages.py |
| G1.5 | "Logging Strategy: Add INFO/DEBUG logging levels" | YES - Added Section 7.1 |
| G1.6 | "Known Bad PDF test: Add error handling test case" | YES - Added Scenario 070 |
| G1.7 | "Use Python 3.9+ native types (list, dict) not typing module" | YES - Noted in Open Questions |

---

### Gemini 3 Pro Review #2 (APPROVED)

**Timestamp:** 2026-01-30
**Reviewer:** Gemini 3 Pro (Senior Software Architect & AI Governance Lead)
**Verdict:** APPROVED

#### Comments

| ID | Comment | Implemented? |
|----|---------|--------------|
| G2.1 | "Ensure pylintrc configured to respect 8.0 threshold in CI" | NOTED - Implementation detail |
| G2.2 | "Ensure requires-python >= 3.9 in pyproject.toml" | NOTED - Implementation detail |

### Review Summary

| Review | Date | Verdict | Key Issue |
|--------|------|---------|-----------|
| Gemini 3 Pro #1 | 2026-01-29 | REVISE | Unbounded loop, worktree scope, fail-safe |
| Gemini 3 Pro #2 | 2026-01-30 | APPROVED | No blocking issues |

**Final Status:** APPROVED
